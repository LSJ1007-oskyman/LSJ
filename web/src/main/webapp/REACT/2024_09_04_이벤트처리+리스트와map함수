이벤트 처리
- event01/Reservation.js
1. 이벤트를 설정하지 않으면 텍스트 입력이나 체크박스 체크도 작동하지 않는다.
2. 반드시 이벤트 설정을 하여서 변화된 값을 value값에 연결해 줘야한다.
3. 체크박스는 누르는 순간 값이 바뀌고 그 다음에 change함수에서 입력된 코드를 실행하므로벤트 처리

- event01/Reservation.js
1. 이벤트를 설정하지 않으면 텍스트 입력이나 체크박스 체크도 작동하지 않는다.
2. 반드시 이벤트 설정을 하여서 변화된 값을 value값에 연결해 줘야한다.
3. 체크박스는 누르는 순간 값이 바뀌고 그 다음에 change함수에서 입력된 코드를 실행하므로 state에 변화된 값을 그냥 e.target.checked로 넘겨줘야 한다.

* state값에 변화가 발생하는 순간 change함수를 먼저 실행한 후에 랜더링을 진행한다.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
리스트

map함수
배열에 저장된 원소값을 반복적으로 구해오는 함수

subject.map((name, index)=>{             
<li key={index}>{name}</li>
 })

- list01/Main.js
1. JSX 구문 안에서 javascript 구문은 { }으로 감싸져야 합니다.
2. render() 의 return값은 항상 한 덩어리여야 합니다.
3. key값은 구분만을 위해 존재한다.

- list01/AttendanceBook.js
1. 리스트 안에 임의의 값을 설정해서 불러올수도 있다. {id:1,name:'홍길동'}, <li key={student.id}>{student.name}</li>
2. 리스트 안에 요소들은 사용자 정의의 임의의 값을 반드시 가져야할 필요는 없음
3. 중간에 새로운 사용자 정의의 임의의 값을 넣을 수도 있음

-list02/App.js+list02/Main1.js+list02/Main2.js+list02/Main3.js
1. const nameList1=names1.map(   (name)      =>       (< Main1     name                            ={name}/>));
                              매개변수name->변경가능         props속성중하나인name->변경불가      매개변수name->변경가능
   const nameList1=names1.map((n)=>(< Main1 name={n}/>)); 이런식으로 쓸수도 있다.
2. 2차원 배열일때는  const nameList2=names2.map((v)=>(<Main2 name={v[0]} age={v[1]}/>));이런식으로 전달 한다.
3. 사용자 정의 변수를 선언했을땐 const nameList3=names3.map((v)=>(<Main3 name={v.userName} age={v.age}/>));이런식으로 전달가능하다.
4. 여기서 map((v)=> 코드에 매개변수 v는 리스트의 요소를 1개씩 차례로 가져오는 것이다.
5. filter함수를 통해서 조건을 만족하는 데이터만 전달할 수 있다.
6. App.js코드상에 nameList4를 let로 선언한 이유는 다음 코드에 재사용하기 위해서다(const는 재사용안됌)
